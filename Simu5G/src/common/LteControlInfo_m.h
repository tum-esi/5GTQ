//
// Generated file, do not edit! Created by opp_msgtool 6.0 from common/LteControlInfo.msg.
//

#ifndef __LTECONTROLINFO_M_H
#define __LTECONTROLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class LteControlInfo;
class FlowControlInfo;
class UserControlInfo;
#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "common/LteCommon_m.h" // import common.LteCommon

#include "inet/common/TagBase_m.h" // import inet.common.TagBase

/**
 * Class generated from <tt>common/LteControlInfo.msg:51</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class LteControlInfo
 * // \@brief Base class for FlowControlInfo and UserControlInfo
 * //
 * // This class contains information present in both Flow and User ControlInfo:
 * // - Source MAC Node ID
 * // - Destination MAC Node ID
 * //
 * class LteControlInfo extends inet::TagBase
 * {
 *     uint16 sourceId;                                     // Source MacNodeId
 *     uint16 destId;                                       // Destination MacNodeId
 *     unsigned short direction \@enum(Direction);            // Traffic Direction (UL, DL, D2D)
 *     uint16 d2dTxPeerId;
 *     uint16 d2dRxPeerId;
 * 
 *     //# Traffic Control Information
 * 
 *     unsigned short application \@enum(ApplicationType);    // Application Type
 *     unsigned short traffic \@enum(LteTrafficClass);        // Lte Traffic Type
 * 
 *     //# 5QI information
 *     unsigned int cid;
 *     unsigned short qfi;
 *     unsigned short radioBearerId;
 * 
 *     unsigned int bytesize;
 *     unsigned int numberOfPacketsInQueue;
 *     unsigned int bytesizeOfOnePacket;
 * 
 *     //# RLC Control Information
 * 
 *     unsigned short rlcType \@enum(LteRlcType);            // RLC Traffic Type
 * 
 *     //# Connection Information
 * 
 *     uint16 lcid;                                        // Logical Connection Identifier
 *     int32 multicastGroupId = -1;                        // Identifier for a multicast group (it is in range [0:[2^28)-1] ) 
 *                                                         // For unicast communications, this field is -1
 *     bool containsSeveralCids = false;
 * 
 * }
 * </pre>
 */
class LteControlInfo : public ::inet::TagBase
{
  protected:
    uint16_t sourceId = 0;
    uint16_t destId = 0;
    unsigned short direction = 0;
    uint16_t d2dTxPeerId = 0;
    uint16_t d2dRxPeerId = 0;
    unsigned short application = 0;
    unsigned short traffic = 0;
    unsigned int cid = 0;
    unsigned short qfi = 0;
    unsigned short radioBearerId = 0;
    unsigned int bytesize = 0;
    unsigned int numberOfPacketsInQueue = 0;
    unsigned int bytesizeOfOnePacket = 0;
    unsigned short rlcType = 0;
    uint16_t lcid = 0;
    int32_t multicastGroupId = -1;
    bool containsSeveralCids = false;

  private:
    void copy(const LteControlInfo& other);

  protected:
    bool operator==(const LteControlInfo&) = delete;

  public:
    LteControlInfo();
    LteControlInfo(const LteControlInfo& other);
    virtual ~LteControlInfo();
    LteControlInfo& operator=(const LteControlInfo& other);
    virtual LteControlInfo *dup() const override {return new LteControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getSourceId() const;
    virtual void setSourceId(uint16_t sourceId);

    virtual uint16_t getDestId() const;
    virtual void setDestId(uint16_t destId);

    virtual unsigned short getDirection() const;
    virtual void setDirection(unsigned short direction);

    virtual uint16_t getD2dTxPeerId() const;
    virtual void setD2dTxPeerId(uint16_t d2dTxPeerId);

    virtual uint16_t getD2dRxPeerId() const;
    virtual void setD2dRxPeerId(uint16_t d2dRxPeerId);

    virtual unsigned short getApplication() const;
    virtual void setApplication(unsigned short application);

    virtual unsigned short getTraffic() const;
    virtual void setTraffic(unsigned short traffic);

    virtual unsigned int getCid() const;
    virtual void setCid(unsigned int cid);

    virtual unsigned short getQfi() const;
    virtual void setQfi(unsigned short qfi);

    virtual unsigned short getRadioBearerId() const;
    virtual void setRadioBearerId(unsigned short radioBearerId);

    virtual unsigned int getBytesize() const;
    virtual void setBytesize(unsigned int bytesize);

    virtual unsigned int getNumberOfPacketsInQueue() const;
    virtual void setNumberOfPacketsInQueue(unsigned int numberOfPacketsInQueue);

    virtual unsigned int getBytesizeOfOnePacket() const;
    virtual void setBytesizeOfOnePacket(unsigned int bytesizeOfOnePacket);

    virtual unsigned short getRlcType() const;
    virtual void setRlcType(unsigned short rlcType);

    virtual uint16_t getLcid() const;
    virtual void setLcid(uint16_t lcid);

    virtual int32_t getMulticastGroupId() const;
    virtual void setMulticastGroupId(int32_t multicastGroupId);

    virtual bool getContainsSeveralCids() const;
    virtual void setContainsSeveralCids(bool containsSeveralCids);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LteControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LteControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/LteControlInfo.msg:98</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class FlowControlInfo
 * // \@brief contains information flowing from LteIp to Mac
 * //
 * // It contains the following information:
 * // - IP Control Informations: the four tuple, a sequence number and
 * //   the header size (IP + Transport) to be used by pdcp ROHC.
 * // - Traffic Control Informations: Application, Direction, Traffic
 * // - RLC Control Informations: the traffic type (TM, UM, AM)
 * // - Connection information: Logical CID
 * //
 * class FlowControlInfo extends LteControlInfo
 * {
 *     uint32 srcAddr;                                       // source IP
 *     uint32 dstAddr;                                       // destination IP
 *     uint16 typeOfService;								  // IP Type Of Service
 *     unsigned int sequenceNumber;                          // packet sequence number
 *     int headerSize;                                       // IP + Transport header size (used by pdcp ROHC)
 *     bool useNR = false;									  // flag for sending this packet using NR
 *     uint16 srcPort;                                          // source port
 *     uint16 dstPort;                                       // destination port
 * }
 * </pre>
 */
class FlowControlInfo : public ::LteControlInfo
{
  protected:
    uint32_t srcAddr = 0;
    uint32_t dstAddr = 0;
    uint16_t typeOfService = 0;
    unsigned int sequenceNumber = 0;
    int headerSize = 0;
    bool useNR = false;
    uint16_t srcPort = 0;
    uint16_t dstPort = 0;

  private:
    void copy(const FlowControlInfo& other);

  protected:
    bool operator==(const FlowControlInfo&) = delete;

  public:
    FlowControlInfo();
    FlowControlInfo(const FlowControlInfo& other);
    virtual ~FlowControlInfo();
    FlowControlInfo& operator=(const FlowControlInfo& other);
    virtual FlowControlInfo *dup() const override {return new FlowControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrcAddr() const;
    virtual void setSrcAddr(uint32_t srcAddr);

    virtual uint32_t getDstAddr() const;
    virtual void setDstAddr(uint32_t dstAddr);

    virtual uint16_t getTypeOfService() const;
    virtual void setTypeOfService(uint16_t typeOfService);

    virtual unsigned int getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned int sequenceNumber);

    virtual int getHeaderSize() const;
    virtual void setHeaderSize(int headerSize);

    virtual bool getUseNR() const;
    virtual void setUseNR(bool useNR);

    virtual uint16_t getSrcPort() const;
    virtual void setSrcPort(uint16_t srcPort);

    virtual uint16_t getDstPort() const;
    virtual void setDstPort(uint16_t dstPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/LteControlInfo.msg:120</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class UserControlInfo
 * // \@brief contains information flowing from Mac to Phy
 * //
 * // It contains the following information:
 * // - H-ARQ Control Information
 * // - PHY Control Informations: Broadcast, Corruption, Type,
 * //   txMode, Resource blocks used, RemoteSet
 * //
 * class UserControlInfo extends LteControlInfo
 * {
 *     \@customize(true);
 * 
 *     bool isNr = false;
 *     double carrierFrequency;         // carrier frequency
 * 
 *     //# H-ARQ Control Information
 * 
 *     unsigned char acid;                // H-ARQ process identifier
 *     unsigned char cw;                // H-ARQ codeword identifier
 *     unsigned char txNumber = 0;            // number of (re)transmissions for the same pdu (1, 2, 3, 4)
 *     bool ndi = true;                    // new data indicator (new data overwrites a process content if present)
 * 
 *     //# PHY Control Informations
 * 
 *     bool isCorruptible;                                // Frame is corruptible
 *     bool isBroadcast = false;                        // Broadcast packet
 *     bool deciderResult;                                // Decider result
 *     double blerTh;                                    // Calculated BLER threshold for this transmission
 *     double blerValue;                                // Extracted BLER for this transmission (blerValue > blerTh ==> corrupted)
 *     unsigned short txMode \@enum(TxMode);                // Traffic Type
 *     unsigned int frameType \@enum(LtePhyFrameType);    // Frame Type
 *     double txPower;                                    //Transmission Power
 *     double d2dTxPower;                                 //D2D Transmission Power (used for feedback reporting of D2D links
 *     // blocks granted on all Remotes, all Bands
 *     unsigned int totalGrantedBlocks;
 * 
 *     unsigned int grantId;		// grantId related to the grand that allowed the sending of a MEC PDU (used only for MAC PDU sent by UEs)
 * 
 *     //#
 *     //# Follows a list of elements only present in
 *     //# the customized class (see LteControlInfo.h):
 *     //#
 *     //# RemoteSet ru;                                // Remote Antenna Set
 *     //# RbMap grantedBlocks;                        // Blocks allocated per Remote, per Band.
 * }
 * </pre>
 *
 * UserControlInfo_Base is only useful if it gets subclassed, and UserControlInfo is derived from it.
 * The minimum code to be written for UserControlInfo is the following:
 *
 * <pre>
 * class UserControlInfo : public UserControlInfo_Base
 * {
 *   private:
 *     void copy(const UserControlInfo& other) { ... }

 *   public:
 *     UserControlInfo() : UserControlInfo_Base() {}
 *     UserControlInfo(const UserControlInfo& other) : UserControlInfo_Base(other) {copy(other);}
 *     UserControlInfo& operator=(const UserControlInfo& other) {if (this==&other) return *this; UserControlInfo_Base::operator=(other); copy(other); return *this;}
 *     virtual UserControlInfo *dup() const override {return new UserControlInfo(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from UserControlInfo_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(UserControlInfo)
 * </pre>
 */
class UserControlInfo_Base : public ::LteControlInfo
{
  protected:
    bool isNr_ = false;
    double carrierFrequency = 0;
    unsigned char acid = 0;
    unsigned char cw = 0;
    unsigned char txNumber = 0;
    bool ndi = true;
    bool isCorruptible_ = false;
    bool isBroadcast_ = false;
    bool deciderResult = false;
    double blerTh = 0;
    double blerValue = 0;
    unsigned short txMode = 0;
    unsigned int frameType = 0;
    double txPower = 0;
    double d2dTxPower = 0;
    unsigned int totalGrantedBlocks = 0;
    unsigned int grantId = 0;

  private:
    void copy(const UserControlInfo_Base& other);

  protected:
    bool operator==(const UserControlInfo_Base&) = delete;
    // make constructors protected to avoid instantiation
    UserControlInfo_Base();
    UserControlInfo_Base(const UserControlInfo_Base& other);
    // make assignment operator protected to force the user override it
    UserControlInfo_Base& operator=(const UserControlInfo_Base& other);

  public:
    virtual ~UserControlInfo_Base();
    virtual UserControlInfo_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class UserControlInfo");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool isNr() const;
    virtual void setIsNr(bool isNr);

    virtual double getCarrierFrequency() const;
    virtual void setCarrierFrequency(double carrierFrequency);

    virtual unsigned char getAcid() const;
    virtual void setAcid(unsigned char acid);

    virtual unsigned char getCw() const;
    virtual void setCw(unsigned char cw);

    virtual unsigned char getTxNumber() const;
    virtual void setTxNumber(unsigned char txNumber);

    virtual bool getNdi() const;
    virtual void setNdi(bool ndi);

    virtual bool isCorruptible() const;
    virtual void setIsCorruptible(bool isCorruptible);

    virtual bool isBroadcast() const;
    virtual void setIsBroadcast(bool isBroadcast);

    virtual bool getDeciderResult() const;
    virtual void setDeciderResult(bool deciderResult);

    virtual double getBlerTh() const;
    virtual void setBlerTh(double blerTh);

    virtual double getBlerValue() const;
    virtual void setBlerValue(double blerValue);

    virtual unsigned short getTxMode() const;
    virtual void setTxMode(unsigned short txMode);

    virtual unsigned int getFrameType() const;
    virtual void setFrameType(unsigned int frameType);

    virtual double getTxPower() const;
    virtual void setTxPower(double txPower);

    virtual double getD2dTxPower() const;
    virtual void setD2dTxPower(double d2dTxPower);

    virtual unsigned int getTotalGrantedBlocks() const;
    virtual void setTotalGrantedBlocks(unsigned int totalGrantedBlocks);

    virtual unsigned int getGrantId() const;
    virtual void setGrantId(unsigned int grantId);
};


namespace omnetpp {

template<> inline LteControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<LteControlInfo*>(ptr.get<cObject>()); }
template<> inline FlowControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<FlowControlInfo*>(ptr.get<cObject>()); }
template<> inline UserControlInfo_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<UserControlInfo_Base*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __LTECONTROLINFO_M_H

